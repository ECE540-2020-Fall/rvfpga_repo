//	bot31_top.v - BOT (Rojobot) 3.1 top level
//
//	Version:		1.0
//	Author:			Roy Kravitz
//	Last Modified:	22-Aug-2017
//	
//	Revision History:
//	-----------------
//	21-Aug-2017		RK		Created this module from bot31.v ver 3.2.  The most significant change
//							from previous versions is that worldmap.v (the BOT world map BRAM file
//							generated by the Vivado memory generator)is removed from the BOT and
//							will have to be moved to the top level of the design.  This was done
//							because world maps can be changed.  In retrospect, the map BRAM is
//							independent of the BOT and used by both the BOT and the application
//							so it probably shouldn't have been included at the start.  This versions
//							also removes the LM_Dist and RM_Dist registers which were deprecated long ago
//	
//	Description
//	-----------
//	This module is the top level module for the BOT 3.1  (Rojobot).  The BOT interfaces
//	to the Application CPU via an 8-bit register interface.  These registers are available
//	as outputs from the module.  Input to the BOT is through a single 8-bit
//	motor control register which contains values for the left and right wheel speed and direction 
//	
//	THIS VERSION (BOT 3.1) IMPLEMENTS VARIABLE SPEED CONTROL ADDS SUPPORT FOR THE USER TO CONFIGURE 
//	THE WHEEL MOVEMENT THRESHOLD AND TYPE OF MOTOR CONTROL  (ON/OFF CONTROL vs. VARIABLE SPEED).  
//////////

module rojobot31 (
	// interface to the application CPU
	input 		[7:0]		MotCtl_in,		// Motor control input	
	output		[7:0] 		LocX_reg,		// X-coordinate of rojobot's location		
							LocY_reg,		// Y-coordinate of rojobot's location
							Sensors_reg,	// Sensor readings
							BotInfo_reg,	// Information about rojobot's activity
							
	// interface to the world map BRAM
	output 		[13:0]		worldmap_addr,	// address to the world map BRAM
	input		[1:0]		worldmap_data,	// data (locationv value) from world map BRAM

	// interface to the system
	input					clk_in,			// clock input to BOT (assume 75MHz)
							reset,			// system reset.  Asserted high for reset
	output					upd_sysregs,	// flag from PicoBlaze to indicate that the system registers 
											// (LocX, LocY, Sensors, BotInfo)have been updated
											
	// BOT configuration register - BOT 3.1 feature									
	input 		[7:0]		Bot_Config_reg	// Bot Configuration register
);

// internal variables for picoblaze and program ROM signals
// signal names taken from kcpsm6_design_template.v
wire	[11:0]		address;
wire	[17:0]		instruction;
wire				bram_enable;
wire				rdl;

wire	[7:0]		port_id;
wire	[7:0]		out_port;
wire	[7:0]		in_port;
wire				write_strobe;
wire				read_strobe;
wire				interrupt;
wire				interrupt_ack;
wire				kcpsm6_sleep; 
wire				kcpsm6_reset;
	
wire 	[7:0]		wrld_col_addr,		// column address for world map BRAM
					wrld_row_addr;		// row address for world map BRAM
wire	[1:0]		wrld_loc_info;		// location data from the world map BRAM to Picoblaze
	
// global assigns
assign kcpsm6_reset = reset;			// Picoblaze is reset w/ global reset signal
assign kcpsm6_sleep = 1'b0;				// kcpsm6 sleep mode is not used
assign interrupt = 1'b0;				// kcpsm6 interrupt is not used	

// create address to the world map BRAM and location info to the Picoblaze
assign worldmap_addr = {wrld_row_addr[6:0], wrld_col_addr[6:0]};
assign wrld_loc_info = worldmap_data;

// instantiate the BOT Picoblaze and its Program ROM
kcpsm6 #(
	.interrupt_vector	(12'h3FF),
	.scratch_pad_memory_size(64),
	.hwbuild		(8'h00))
  BOTCPU (
	.address 		(address),
	.instruction 	(instruction),
	.bram_enable 	(bram_enable),
	.port_id 		(port_id),
	.write_strobe 	(write_strobe),
	.k_write_strobe (),				// Constant Optimized writes are not used in this implementation
	.out_port 		(out_port),
	.read_strobe 	(read_strobe),
	.in_port 		(in_port),
	.interrupt 		(interrupt),
	.interrupt_ack 	(),				// Interrupt is not used in this implementation
	.reset 			(kcpsm6_reset),
	.sleep			(kcpsm6_sleep),
	.clk 			(clk_in)
); 

 // instantiate the BOTSIM program ROM
 // JTAG update is disabled - This is the "production" BOTSIM
 // so save the functionality for the Application program
 bot31_pgm BOTSIMPGM ( 
	.enable 		(bram_enable),
	.address 		(address),
	.instruction 	(instruction),
	.clk 			(clk_in));

// instantiate the interface to the Application CPU
bot31_if  BOTREGIF (
	// interface to the picoblaze
	.Wr_Strobe(write_strobe),		// Write strobe - asserted to write I/O data
	.Rd_Strobe(read_strobe),		// Read strobe - asserted to read I/O data
	.AddrIn(port_id),
	.DataIn(out_port),				// Data to be written to I/O register
	.DataOut(in_port),				// Data to be read from I/O register
	
	// interface to the application CPU	
	// These registers contain the motor control input and the current state of the BOT
	.MotCtl(MotCtl_in),				// Motor control input	
	.LocX(LocX_reg),				// X-coordinate of rojobot's location		
	.LocY(LocY_reg),				// Y-coordinate of rojobot's location
	.BotInfo(BotInfo_reg),			// Information about rojobot's activity
	.Sensors(Sensors_reg),			// Sensor readings
												
	// interface to the world map BRAM.  The world map BRAM is dual-port ROM
	// Port A is used by the BOT firmware to get the value of the current location
	// location of the BOT (line, obstruction, open, reserved).  Port B of the BRAM
	// will be used by the VGA logic to draw the map
	.MapX(wrld_col_addr),
	.MapY(wrld_row_addr),
	.MapVal(wrld_loc_info),
	
	// system-wide signals	
	.clk(clk_in),					// 25Mhz system clock
	.reset(reset),					// system reset
			
	// update system registers (interrupt request to Application CPU
	.upd_sysregs(upd_sysregs),		// flag from PicoBlaze to indicate that the system registers 
									// (LocX, LocY, Sensors, BotInfo)have been updated
									
	// BOT Config register - BOTSIM 3.0
	.BotConfig(Bot_Config_reg)
);
			
endmodule
						
